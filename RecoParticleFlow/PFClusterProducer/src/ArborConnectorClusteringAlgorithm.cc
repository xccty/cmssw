/*
 *
 * ArborConnectorClusteringAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. fï¿½vr. 20 2014
 *
 * This file is part of ArborPFA libraries.
 * 
 * ArborPFA is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborPFA is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborPFA.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @author L. Gray, FNAL (for CMSSW port)
 * @copyright CNRS , IPNL
 */

#include "RecoParticleFlow/PFClusterProducer/interface/PFClusterBuilderBase.h"
#include "DataFormats/ParticleFlowReco/interface/PFRecHitFraction.h"
#include "DataFormats/ParticleFlowReco/interface/PFRecHit.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "DataFormats/Math/interface/deltaR.h"

#include "Math/GenVector/VectorUtil.h"

#include "vdt/vdtMath.h"

#include <iterator>

#ifdef PFLOW_DEBUG
#define LOGVERB(x) edm::LogVerbatim(x)
#define LOGWARN(x) edm::LogWarning(x)
#define LOGERR(x) edm::LogError(x)
#define LOGDRESSED(x) edm::LogInfo(x)
#else
#define LOGVERB(x) LogTrace(x)
#define LOGWARN(x) edm::LogWarning(x)
#define LOGERR(x) edm::LogError(x)
#define LOGDRESSED(x) LogDebug(x)
#endif

#include <unordered_map>

namespace {
  typedef std::vector<std::tuple<const reco::PFCluster*,const reco::PFCluster*,bool> > connector_list; // first connector, second connector, isFinal
  typedef std::vector<std::pair<unsigned,unsigned> > connector_idx_list;
  struct connected_cluster {
    const reco::PFCluster *cluster;
    connector_list connectors;
    unsigned cluster_idx;
    connector_idx_list connectors_idx;
  };
}

class ArborConnectorClusteringAlgorithm : public PFClusterBuilderBase {
  typedef ArborConnectorClusteringAlgorithm B2DGPF;
 public:
  ArborConnectorClusteringAlgorithm(const edm::ParameterSet& conf);
    
  virtual ~ArborConnectorClusteringAlgorithm() {}
  ArborConnectorClusteringAlgorithm(const B2DGPF&) = delete;
  B2DGPF& operator=(const B2DGPF&) = delete;

  void update(const edm::EventSetup& es) { }

  void buildClusters(const reco::PFClusterCollection&,
		     const std::vector<bool>&,
		     reco::PFClusterCollection& outclus);

 private:  
  const double m_maximumForwardDistanceForConnection;
  const double m_maximumTransverseDistanceForConnection;
  const double m_orderParameterAnglePower;
  const double m_orderParameterDistancePower;
  const unsigned m_maximumNumberOfKeptConnectors;
  const bool m_shouldUseIsolatedObjects;
  const bool m_allowForwardConnectionForIsolatedObjects;    
  
  void SeedInitialConnectors(const reco::PFClusterCollection& input,
			     std::vector<connected_cluster>& connectors) const;

  void CleanConnectors(std::vector<connected_cluster>& connectors) const; 

  void RecursiveClustering(const std::vector<connected_cluster>& clusters,
			   const unsigned index,
			   std::vector<bool>& used,
			   reco::PFCluster& clusterToBuild) const;
  
  double computeOrderParameter(const reco::PFCluster*,
			       const reco::PFCluster*,
			       const math::XYZVector& refVector) const; 
};

DEFINE_EDM_PLUGIN(PFClusterBuilderFactory,
		  ArborConnectorClusteringAlgorithm,
		  "ArborConnectorClusteringAlgorithm");

ArborConnectorClusteringAlgorithm::
ArborConnectorClusteringAlgorithm(const edm::ParameterSet& conf) :
    PFClusterBuilderBase(conf),
    m_maximumForwardDistanceForConnection(0.1*conf.getParameter<double>("MaximumForwardDistanceForConnection")),
    m_maximumTransverseDistanceForConnection(0.1*conf.getParameter<double>("MaximumTransverseDistanceForConnection")),  
    m_orderParameterAnglePower(conf.getParameter<double>("OrderParameterAnglePower")),
    m_orderParameterDistancePower(conf.getParameter<double>("OrderParameterDistancePower")),
    m_maximumNumberOfKeptConnectors(conf.getParameter<unsigned>("MaximumNumberOfKeptConnectors")),
    m_shouldUseIsolatedObjects(conf.getParameter<bool>("ShouldUseIsolatedObjects")),
    m_allowForwardConnectionForIsolatedObjects(conf.getParameter<bool>("AllowForwardConnectionForIsolatedObjects")) {  
}

// helper functions / typedefs
namespace {    
  inline double openingAngle(const math::XYZVector& one,
			     const math::XYZVector& two) {
    const double mag2s = one.Mag2() * two.Mag2();
    return vdt::fast_acos(two.Dot(one)/std::sqrt(mag2s));
  }

  inline double openingAngle(const reco::PFCluster& one,
			     const reco::PFCluster& two) {
    const math::XYZPoint zero(0,0,0);
    const math::XYZVector one_vec = one.position() - zero;
    const math::XYZVector diff_vec = two.position() - one.position();
    return openingAngle(one_vec,diff_vec);
  }

  inline std::pair<float,float> 
  getConnectionDistances(const reco::PFCluster& one,
			 const reco::PFCluster& two) {
    
    constexpr double pi_over_2 = M_PI/2.0;
    const math::XYZVector diff_vec = two.position() - one.position();
    const double diffMag2 = diff_vec.Mag2();
    const double diffMag =  std::sqrt(diffMag2);
    const double angle = openingAngle(one,two);
    const double sinangle = vdt::fast_sin(angle);
    const double cosangle = std::sqrt((1-sinangle)*(1+sinangle));
    const double tvDist = 
      ( angle < pi_over_2 ? std::abs(diffMag*sinangle) : 
	std::numeric_limits<double>::max() );
    const double forwardDist = 
      ( angle < pi_over_2 ? std::abs(diffMag*cosangle) : 
	std::numeric_limits<double>::max() );
    
    return std::make_pair(forwardDist,tvDist);
  }

  bool isBackwardConnector(const reco::PFCluster* connect_to,
			   const connector_list::value_type& connector) {
    //constexpr double pi_over_two = M_PI/2.0;
    const reco::PFCluster* other = ( connect_to == std::get<0>(connector) ?
				     std::get<1>(connector) : 
				     std::get<0>(connector)                 );
    double zDiff = ( std::abs(other->position().z()) - 
		     std::abs(connect_to->position().z()) );
    if( zDiff < 0 ) {
      std::cout << "backwards connector: " << zDiff << std::endl;
    } else {
      std::cout << "forwards connector: " << zDiff << std::endl;
    }
    return zDiff < 0;
  }

  void computeMeanBackwardDirection(const connected_cluster& cluster,
				    math::XYZVector& meanBackwardDirection,
				    unsigned& nBackwardConnections) {
    const math::XYZVector zero(0,0,0);
    meanBackwardDirection = math::XYZVector(0,0,0);
    nBackwardConnections = 0;
    
    const connector_list& connectors = cluster.connectors;    
    const reco::PFCluster* this_cluster = cluster.cluster;

    for( const auto& connector : connectors ) {      
      const bool isBackwards = isBackwardConnector(this_cluster,connector);
      if( !isBackwards ) continue;
      const reco::PFCluster* other_cluster = 
	( this_cluster == std::get<0>(connector) ? 
	  std::get<1>(connector) : std::get<0>(connector) );
      ++nBackwardConnections;      
      meanBackwardDirection += ( other_cluster->position() - 
				 this_cluster->position()    );
    }
  }
  
  bool isConnectedWith(const connected_cluster& cluster1,
		       const connected_cluster& cluster2) {
    if(!cluster1.connectors.size()) return false;
    for( const auto& connector : cluster1.connectors) {
      const reco::PFCluster* link1 = std::get<0>(connector);
      const reco::PFCluster* link2 = std::get<1>(connector);
      if( link1 == cluster2.cluster || link2 == cluster2.cluster ) return true;
    }
    return false;	
  }

  void makeConnection(connected_cluster& cluster1,
		      connected_cluster& cluster2) {
    if( cluster1.cluster == cluster2.cluster ) return;
    bool already_connected = false;
    for( unsigned i = 0; i < cluster2.connectors.size(); ++i ) {
      auto& connector = cluster2.connectors[i];
      if( std::get<0>(connector) == cluster1.cluster ||
	  std::get<1>(connector) == cluster1.cluster    ) {
	already_connected = true;
	cluster1.connectors.push_back(cluster2.connectors[i]);
	cluster1.connectors_idx.push_back(cluster2.connectors_idx[i]);
      }
    }
    if( !already_connected ) {
      cluster1.connectors.emplace_back(cluster1.cluster,cluster2.cluster,false);
      cluster1.connectors_idx.emplace_back(cluster1.cluster_idx,
					   cluster2.cluster_idx);
      cluster2.connectors.emplace_back(cluster1.cluster,cluster2.cluster,false);
      cluster2.connectors_idx.emplace_back(cluster1.cluster_idx,
					   cluster2.cluster_idx);
    }
  }  
  
  void removeConnection(connected_cluster& cluster1,
			connected_cluster& cluster2) {
    if( cluster1.cluster == cluster2.cluster ) return;
    auto one_to_two = std::find_if(cluster2.connectors.begin(),
				cluster2.connectors.end(),
				[&](const connector_list::value_type& a) {
				  return ( std::get<0>(a) == cluster1.cluster ||
					   std::get<1>(a) == cluster1.cluster);
				});
    auto two_to_one = std::find_if(cluster1.connectors.begin(),
				cluster1.connectors.end(),
				[&](const connector_list::value_type& a) {
				  return ( std::get<0>(a) == cluster2.cluster ||
					   std::get<1>(a) == cluster2.cluster);
				});
    if( one_to_two != cluster2.connectors.end() ) {
      std::cout << "erasing cluster one in two!" << std::endl;
      unsigned dist_two = std::distance(cluster2.connectors.begin(),one_to_two);
      cluster2.connectors.erase(one_to_two);
      cluster2.connectors_idx.erase(cluster2.connectors_idx.begin()+dist_two);
    }
    if( two_to_one != cluster1.connectors.end() ) {
       std::cout << "erasing cluster two in one!" << std::endl;
      unsigned dist_one = std::distance(cluster1.connectors.begin(),two_to_one);
      cluster1.connectors.erase(two_to_one);     
      cluster1.connectors_idx.erase(cluster1.connectors_idx.begin()+dist_one);
    }
     if( one_to_two == cluster2.connectors.end() &&
	 two_to_one == cluster1.connectors.end() ) {
       throw cms::Exception("WeirdLink") 
	 << "Couldn't delete either link in clusters, weird!" << std::endl;
     }
  }
 

  void setConnectionFinal(connected_cluster& cluster1,
			  connected_cluster& cluster2) {
    if( cluster1.cluster == cluster2.cluster ) return;
    auto one_to_two = std::find_if(cluster2.connectors.begin(),
				cluster2.connectors.end(),
				[&](const connector_list::value_type& a) {
				  return ( std::get<0>(a) == cluster1.cluster ||
					   std::get<1>(a) == cluster1.cluster);
				});
    auto two_to_one = std::find_if(cluster1.connectors.begin(),
				   cluster1.connectors.end(),
				[&](const connector_list::value_type& a) {
				  return ( std::get<0>(a) == cluster2.cluster ||
					   std::get<1>(a) == cluster2.cluster);
				});
    if( one_to_two != cluster2.connectors.end() ) {
      std::get<2>(*one_to_two) = true;
    }
    if( two_to_one != cluster1.connectors.end() ) {      
      std::get<2>(*two_to_one) = true;
    }
  }
}

void ArborConnectorClusteringAlgorithm::
buildClusters(const reco::PFClusterCollection& input,
	      const std::vector<bool>& seedable,
	      reco::PFClusterCollection& output) {
  std::vector<bool> used(input.size(),false);

  std::vector<connected_cluster> connectors;
  std::cout << "seeding connectors" << std::endl;  
  SeedInitialConnectors(input,connectors);
  std::cout << "seeded connectors!" << std::endl;

  std::cout << "cleaning connectors" << std::endl;
  CleanConnectors(connectors);
  std::cout << "cleaned connectors!" << std::endl;

  // this is the "DoClustering()" function
  std::cout << "building final clusters!" << std::endl;
  for( unsigned i = 0; i < connectors.size(); ++i ) {
    if( used[i] ) continue;
    reco::PFCluster temp;
    //std::cout << "recursively tracing connectors" << std::endl;    
    bool hasOnlyBackwardConnector = true;
    for( const auto& connector : connectors[i].connectors ) {
      if( !isBackwardConnector(connectors[i].cluster,connector) ) {
	hasOnlyBackwardConnector = false;
	break;
      }
    }
    if( hasOnlyBackwardConnector ) {
      RecursiveClustering(connectors,i,used,temp);
      temp.setEnergy(temp.recHitFractions().size());
      //std::cout << "traversed connectors for " << i << std::endl;
      output.push_back(std::move(temp));
    }
  }

  std::cout << "Made " << output.size() << " PF-Arbor clusters!" << std::endl;
}

void ArborConnectorClusteringAlgorithm::
SeedInitialConnectors(const reco::PFClusterCollection& input,
		      std::vector<connected_cluster>& connectors) const {  
  connectors.clear();
  connectors.reserve(input.size());
  for( unsigned i = 0; i < input.size(); ++i ) {
    connected_cluster temp;
    temp.cluster = &input[i];
    temp.cluster_idx = i;
    connectors.push_back(std::move(temp));
  }
  for( connected_cluster& conn : connectors ) {
    for( connected_cluster& other_conn : connectors ) {
      if( conn.cluster == other_conn.cluster ) continue;
      if(!isConnectedWith(conn,other_conn)) {
	std::pair<double,double> dists = 
	  getConnectionDistances(*conn.cluster,*other_conn.cluster);
	if( dists.first < m_maximumForwardDistanceForConnection &&
	    dists.second < m_maximumTransverseDistanceForConnection ) {
	  /*
	  std::cout << "made connection: " << dists.first 
		    << ' ' << dists.second << std::endl;
	  */
	  makeConnection(conn,other_conn);
	}
      }
    }
  }
}

void  ArborConnectorClusteringAlgorithm::
CleanConnectors(std::vector<connected_cluster>& clusters) const {
  for( auto& conn_cluster : clusters ) {
    const reco::PFCluster* current = conn_cluster.cluster;
    math::XYZVector meanBackwardDir(0,0,0);
    unsigned nBackwardConnections = 0;
    double bestOrderParameter = std::numeric_limits<double>::max();
    const reco::PFCluster* bestConnection = nullptr;
    computeMeanBackwardDirection(conn_cluster,
				 meanBackwardDir,
				 nBackwardConnections);
    
    
    std::cout << "found " << nBackwardConnections 
	      << " back-links" << std::endl;
    
    if(!nBackwardConnections) continue; // if nothing behind we skip
    for( auto& connector : conn_cluster.connectors ) {
      // get backward connectors that are not finalized
      if( isBackwardConnector(conn_cluster.cluster,connector) && 
	  !std::get<2>(connector) ) {
	const reco::PFCluster* other = ( current == std::get<0>(connector) ?
					 std::get<1>(connector) :
					 std::get<0>(connector) );
	const double orderParm = computeOrderParameter(current,other,
						       meanBackwardDir.unit());
	if( orderParm < bestOrderParameter ) {
	  bestOrderParameter = orderParm;
	  bestConnection = other;
	}	
      }
    }
    // if we have a best connection, remove everything else
    if( bestConnection != nullptr ) {
      const double oneZ = std::abs(conn_cluster.cluster->position().z());
      const double twoZ = std::abs(bestConnection->position().z());
      if( twoZ - oneZ < 0.0 ) std::cout << "best connection is backwards! " 
					<< twoZ - oneZ << std::endl;
      if( twoZ - oneZ > 0.0 ) std::cout << "best connection is forwards! " 
					<< twoZ - oneZ << std::endl;

      auto iter = conn_cluster.connectors.begin();
      while( iter != conn_cluster.connectors.end() ) {
	//std::cout << "removing all but the best!" << std::endl;
	unsigned relative_idx = std::distance(conn_cluster.connectors.begin(),
					      iter);
	auto& the_connector = *iter;
	auto& the_connector_idx = *( conn_cluster.connectors_idx.begin() + 
				     relative_idx );
	const unsigned other_clus_idx = 
	  (  conn_cluster.cluster == std::get<0>(the_connector) ? 
	     the_connector_idx.second : the_connector_idx.first );
	if( std::get<0>(the_connector) == bestConnection ||
	    std::get<1>(the_connector) == bestConnection    ){
	  std::cout << "setting final connector" << std::endl;
	  setConnectionFinal(conn_cluster,clusters[other_clus_idx]);
	  ++iter;
	} else {
	  if( isBackwardConnector(conn_cluster.cluster,the_connector) ) {
	    std::cout << "removing backward connector" << std::endl;
	    removeConnection(conn_cluster,clusters[other_clus_idx]);
	    conn_cluster.connectors_idx.erase(conn_cluster.connectors_idx.begin()+
					      relative_idx);
	    iter = conn_cluster.connectors.begin()+relative_idx;
	  } else {
	    std::cout << "advancing past forward connector" << std::endl;
	    ++iter;
	  }
	}
      }
      computeMeanBackwardDirection(conn_cluster,
				   meanBackwardDir,
				   nBackwardConnections);
      //if( nBackwardConnections > 1 ) {
	std::cout << "Ended with this many connections! " 
		  << nBackwardConnections << std::endl;
	//}
    }
  }
}

void ArborConnectorClusteringAlgorithm::
RecursiveClustering(const std::vector<connected_cluster>& clusters,
		    const unsigned index,
		    std::vector<bool>& used,
		    reco::PFCluster& clusterToBuild) const {  
  if( used[index] ) return;
  //std::cout << "inside recursive clustering with index " << index << std::endl;
  used[index] = true;
  const connected_cluster& clus = clusters[index];
  //std::cout <<  clus.cluster << ' ' <<  clus.connectors.size() << std::endl;
  for( auto iter = clus.connectors.cbegin();
       iter != clus.connectors.cend(); ++iter ) {
    /*
    std::cout << " at connector index " 
	      << std::distance(clus.connectors.cbegin(),iter) << std::endl;    
    */
    if( std::get<2>(*iter) ) {
      unsigned conn_idx = std::distance(clus.connectors.begin(),iter);
      /*
      std::cout << "connector idx : " << conn_idx << ' ' 
		<< clus.connectors.size() << ' ' 
		<< clus.connectors_idx.size() << std::endl;
      */
      const reco::PFCluster* other = nullptr;
      unsigned other_idx = std::numeric_limits<unsigned>::max();
      if( std::get<0>(*iter) == clus.cluster ) {
	other = std::get<1>(*iter);
	other_idx = std::get<1>(*(clus.connectors_idx.begin()+conn_idx));
      } else {
	other = std::get<0>(*iter);
	other_idx = std::get<0>(*(clus.connectors_idx.begin()+conn_idx));
      }
      for( const auto& rhf : other->recHitFractions() ) {
	clusterToBuild.addRecHitFraction(rhf);
      }
      RecursiveClustering(clusters,other_idx,used,clusterToBuild);
    }// make sure we are traversing finalized connectors
  }
}

double ArborConnectorClusteringAlgorithm::
computeOrderParameter(const reco::PFCluster* one,
		      const reco::PFCluster* two,
		      const math::XYZVector& refVector) const {
  const math::XYZVector diffPos = two->position() - one->position();
  const double angle = openingAngle(diffPos,refVector);
  return ( std::pow(angle,m_orderParameterAnglePower) *
	   std::pow(diffPos.Mag2(),0.5*m_orderParameterDistancePower) );
}
